<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>《菩提道次第广论》手抄稿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg-page: #f0f2f5;
            --bg-card: #ffffff;
            --text-primary: #111827;
            --text-secondary: #374151;
            --text-quote: #4a5568;
            --border-color: #cbd5e0;
            --highlight-bg: #e0f2fe;
            --highlight-text: #1d4ed8;
            --hover-bg: #e0f2fe; 
            --shadow-light: rgba(0,0,0,0.05);
            --shadow-medium: rgba(0,0,0,0.1);
            /* New variable: set dynamically by JS to be header height + padding */
            --header-clearance-height: 200px; 
        }

        .dark {
            --bg-page: #1a202c;
            --bg-card: #2d3748;
            --text-primary: #e2e8f0;
            --text-secondary: #a0aec0;
            --text-quote: #a0aec0;
            --border-color: #4a5568;
            --highlight-bg: #4c51bf;
            --highlight-text: #e0f2fe;
            --hover-bg: #667eea; 
            --shadow-light: rgba(0,0,0,0.2);
            --shadow-medium: rgba(0,0,0,0.3);
        }

        /* --- HYPER-AGGRESSIVE CSS RESET FOR HOST ENVIRONMENT --- */
        html, body, #app-container {
            margin: 0 !important; 
            padding: 0 !important; 
            height: 100% !important; 
            min-height: 100% !important;
            box-sizing: border-box !important;
            overflow: hidden; 
        }
        /* -------------------------------------------------------- */


        html, body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-page);
            color: var(--text-primary);
        }

        #app-container {
            height: 100vh !important; 
            position: relative;
            background-color: var(--bg-page);
        }

        #fixed-header-area {
            position: absolute !important; 
            top: 0 !important; 
            left: 0;
            right: 0;
            z-index: 100;
            background-color: var(--bg-page);
            padding: 0.75rem 0;
            box-shadow: 0 2px 8px var(--shadow-medium);
            transition: transform 0.3s ease-in-out;
        }
        
        #main-content-scrollable-wrapper {
            height: 100%; 
            overflow-y: auto;
            padding-left: 1rem;
            padding-right: 1rem;
            padding-bottom: 2rem;
            transition: margin-top 0.3s ease-in-out;
        }
        
        /* Dark Mode Fix for Dropdown Select Element */
        .dark #episode-select {
            background-color: var(--bg-card); 
            color: var(--text-primary);     
            border-color: var(--border-color); 
        }

        /* Restore vertical paragraph spacing */
        #transcript-content p {
            margin-bottom: 1.5rem; 
        }
        
        /* --- Restore Markdown Header Styling --- */
        #transcript-content h1, 
        #transcript-content h2, 
        #transcript-content h3 {
            font-weight: bold;
            margin-top: 2.5rem;   /* Space above header */
            margin-bottom: 1rem;  /* Space below header */
            line-height: 1.2;
        }
        #transcript-content h1 { font-size: 1.8em; }
        #transcript-content h2 { font-size: 1.6em; }
        #transcript-content h3 { font-size: 1.4em; }
        /* -------------------------------------- */

        #transcript-content blockquote {
            margin: 1.5rem 0;
            padding-left: 1rem;
            border-left: 4px solid var(--border-color);
            color: var(--text-quote);
            font-style: italic;
        }
        
        .transcript-segment {
            padding: 4px 0px;
            border-radius: 4px;
            /* Removed background-color transition to prevent flicker on hover/click */
            transition: box-shadow 0.2s ease-in-out, font-weight 0.2s ease-in-out, color 0.2s ease-in-out; 
            cursor: pointer;
            line-height: 1.625;
            white-space: normal;
            scroll-margin-top: var(--header-clearance-height);
        }

        .highlight-active {
            background-color: var(--highlight-bg);
            box-shadow: 0 2px 4px var(--shadow-light);
            color: var(--highlight-text);
        }

        #transcript-content {
            scroll-behavior: smooth;
            text-align: justify;
            padding: 1rem; /* Keeps inner text readable, away from edges */
            color: var(--text-primary);
        }
        .audio-player-container {
            background-color: var(--bg-card);
            padding: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-medium);
            margin-bottom: 0rem;
        }
        @media (min-width: 768px) {
            .audio-player-container {
                padding: 1.5rem;
            }
        }

        .transcript-container {
            background-color: var(--bg-card);
            padding: 0; /* Updated: Set padding to zero as requested (4) */
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-medium);
            margin-bottom: 2rem;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Header is ABSOLUTE, sitting on top of the content -->
        <div id="fixed-header-area" class="flex flex-col items-center">
            <div class="w-full sm:max-w-5xl lg:max-w-6xl mx-auto px-4">
                <div class="flex flex-col md:flex-row items-center justify-between mb-1 md:mb-2">
                    <header class="text-center md:text-left mb-1 md:mb-0 md:mr-4">
                        <h1 class="text-2xl md:text-3xl font-extrabold my-0" style="color: var(--text-primary);">《菩提道次第广论》手抄稿</h1>
                    </header>
                    <div class="flex items-center w-full md:w-auto">
                        <!-- Updated: Added classes for truncation on mobile (3) -->
                        <select id="episode-select" class="p-2 border rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 w-full md:w-auto overflow-hidden text-ellipsis whitespace-nowrap">
                            <option value="">Loading episodes...</option>
                        </select>
                    </div>
                </div>

                <section class="audio-player-container w-full">
                    <div class="flex flex-col md:flex-row items-center justify-between space-y-2 md:space-y-0">
                        <audio id="podcast-audio" controls class="w-full md:w-auto md:flex-grow rounded-lg shadow-inner mr-0 md:mr-4" crossorigin="anonymous"> 
                            Your browser does not support the audio element.
                        </audio>

                        <div class="flex items-center space-x-2 md:space-x-4 w-full md:w-auto justify-center md:justify-end mt-2 md:mt-0">
                            <button id="dark-mode-toggle" class="whitespace-nowrap text-sm md:text-base" aria-label="Toggle Dark Mode">
                                <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 inline-block align-middle"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="M4.93 4.93l1.41 1.41"></path><path d="M17.66 17.66l1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="M6.34 17.66l-1.41 1.41"></path><path d="M19.07 4.93l-1.41 1.41"></path></svg>
                                <svg id="moon-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 inline-block align-middle hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                            </button>
                            <div id="font-size-controls" class="flex items-center space-x-1">
                                <span class="whitespace-nowrap text-sm md:text-base" style="color: var(--text-secondary);" aria-label="Font Size">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 inline-block align-middle"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
                                </span>
                                <button id="font-size-decrease" 
                                    class="w-8 h-8 flex items-center justify-center font-bold text-lg rounded-full shadow-md transition duration-150 ease-in-out bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600"
                                    aria-label="Decrease Font Size">-</button>
                                <button id="font-size-increase"
                                    class="w-8 h-8 flex items-center justify-center font-bold text-lg rounded-full shadow-md transition duration-150 ease-in-out bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-200 dark:hover:bg-gray-600"
                                    aria-label="Increase Font Size">+</button>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
        
        <!-- This is the scrollable container. Its margin-top manages the gap. -->
        <div id="main-content-scrollable-wrapper">
            <div id="main-content-area" class="w-full sm:max-w-5xl lg:max-w-6xl mx-auto space-y-6">
                <section class="transcript-container">
                    <div id="transcript-content" class="leading-relaxed">
                        Loading transcript...
                    </div>

                    <div id="raw-markdown-transcript" class="hidden"></div>
                </section>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const audioPlayer = document.getElementById('podcast-audio');
            const transcriptContent = document.getElementById('transcript-content');
            const episodeSelect = document.getElementById('episode-select');
            const fixedHeaderArea = document.getElementById('fixed-header-area');
            const scrollWrapper = document.getElementById('main-content-scrollable-wrapper'); // SCROLL TARGET

            const darkModeToggle = document.getElementById('dark-mode-toggle');
            const sunIcon = document.getElementById('sun-icon');
            const moonIcon = document.getElementById('moon-icon');
            const fontSizeDecreaseBtn = document.getElementById('font-size-decrease');
            const fontSizeIncreaseBtn = document.getElementById('font-size-increase');
            
            audioPlayer.crossOrigin = "anonymous";

            // Updated: Increased padding to prevent header clipping on reveal (2)
            const CONTENT_PADDING_TOP = 40; 

            let playlist = [];
            let timestampSegments = [];
            let currentSegmentIndex = -1;
            // Default Text Size is 20px
            let currentFontSize = 20; 
            const FONT_SIZE_STEP = 2;
            const PLAYLIST_URL = "https://raw.githubusercontent.com/chee-hung/lamrim/main/public/playlist.json?t=" + new Date().getTime();
            const LAST_PLAYED_STATE_KEY = 'lastPlayedState';
            
            let lastScrollTop = 0;
            // Updated: Increased scroll threshold for less sensitive auto-hiding (1)
            const scrollThreshold = 100; 
            
            let isProgrammaticScroll = false;
            const PROGRAMMATIC_SCROLL_DURATION = 800; // Time buffer to ignore programmatic scroll events

            function updateContentMargin(isHidden, fixedHeaderHeight) {
                const clearanceHeight = isHidden ? CONTENT_PADDING_TOP : (fixedHeaderHeight + CONTENT_PADDING_TOP); 
                
                scrollWrapper.style.marginTop = `${clearanceHeight}px`;
                document.documentElement.style.setProperty('--header-clearance-height', `${clearanceHeight}px`);
            }
            
            function handleScroll(event) {
                if (isProgrammaticScroll) {
                    return; 
                }

                const currentScroll = event.target.scrollTop;
                const fixedHeaderHeight = fixedHeaderArea.offsetHeight;
                
                if (currentScroll !== lastScrollTop) {
                    
                    if (currentScroll > lastScrollTop && currentScroll > scrollThreshold) {
                        // Scrolling Down -> Hide Header
                        if (!fixedHeaderArea.classList.contains('header-hidden')) {
                             fixedHeaderArea.style.transform = `translateY(-${fixedHeaderHeight}px)`;
                             fixedHeaderArea.classList.add('header-hidden');
                             updateContentMargin(true, fixedHeaderHeight); 
                        }
                    } 
                    else if (currentScroll < lastScrollTop || currentScroll <= CONTENT_PADDING_TOP) {
                        // Scrolling Up or near top -> Show Header
                        if (fixedHeaderArea.classList.contains('header-hidden')) {
                            fixedHeaderArea.style.transform = 'translateY(0)';
                            fixedHeaderArea.classList.remove('header-hidden');
                            updateContentMargin(false, fixedHeaderHeight);
                        }
                    }
                }

                lastScrollTop = currentScroll;
            }
            
            scrollWrapper.addEventListener('scroll', handleScroll, { passive: true });

            function toggleDarkMode() {
                document.documentElement.classList.toggle('dark');
                const isDarkMode = document.documentElement.classList.contains('dark');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                updateDarkModeIcon(isDarkMode);
            }

            function updateDarkModeIcon(isDarkMode) {
                if (isDarkMode) {
                    sunIcon.classList.add('hidden');
                    moonIcon.classList.remove('hidden');
                } else {
                    sunIcon.classList.remove('hidden');
                    moonIcon.classList.add('hidden');
                }
            }

            function applySavedTheme() {
                const savedTheme = localStorage.getItem('theme');
                const isDarkMode = savedTheme === 'dark';
                if (isDarkMode) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                updateDarkModeIcon(isDarkMode);
            }

            function changeFontSize(step) {
                currentFontSize += step;
                if (currentFontSize < 12) currentFontSize = 12;
                if (currentFontSize > 36) currentFontSize = 36;

                transcriptContent.style.fontSize = `${currentFontSize}px`;
                localStorage.setItem('transcriptFontSize', currentFontSize);
            }

            function applySavedFontSize() {
                const savedFontSize = localStorage.getItem('transcriptFontSize');
                if (savedFontSize) {
                    currentFontSize = parseInt(savedFontSize, 10);
                } else {
                    currentFontSize = 20; // Default: 20px
                }
                transcriptContent.style.fontSize = `${currentFontSize}px`;
            }

            function saveVolume() {
                localStorage.setItem('audioVolume', audioPlayer.volume);
            }

            function applySavedVolume() {
                const savedVolume = localStorage.getItem('audioVolume');
                if (savedVolume !== null) {
                    audioPlayer.volume = parseFloat(savedVolume);
                } else {
                    audioPlayer.volume = 0.5;
                }
            }

            function savePlaybackState() {
                const state = {
                    episodeIndex: episodeSelect.value,
                    currentTime: audioPlayer.currentTime
                };
                localStorage.setItem(LAST_PLAYED_STATE_KEY, JSON.stringify(state));
            }

            function applySavedPlaybackState() {
                const savedStateString = localStorage.getItem(LAST_PLAYED_STATE_KEY);
                if (savedStateString) {
                    try {
                        const savedState = JSON.parse(savedStateString);
                        if (savedState.episodeIndex !== undefined && savedState.currentTime !== undefined &&
                            parseInt(savedState.episodeIndex) < playlist.length) {
                            return {
                                episodeIndex: parseInt(savedState.episodeIndex),
                                startTime: parseFloat(savedState.currentTime)
                            };
                        }
                    } catch (e) {
                        console.error("Error parsing saved playback state:", e);
                        localStorage.removeItem(LAST_PLAYED_STATE_KEY);
                    }
                }
                return null;
            }

            function setInitialLayout() {
                const fixedHeaderHeight = fixedHeaderArea.offsetHeight;
                updateContentMargin(false, fixedHeaderHeight);
            }

            const resizeObserver = new ResizeObserver(entries => {
                setInitialLayout();
            });
            resizeObserver.observe(fixedHeaderArea);

            setInitialLayout();
            window.addEventListener('resize', setInitialLayout);

            function toggleHighlight(index, addHighlight) {
                if (index >= 0 && index < timestampSegments.length) {
                    const segment = timestampSegments[index];
                    if (segment.element) {
                        if (addHighlight) {
                            segment.element.classList.add('highlight-active');
                        } else {
                            segment.element.classList.remove('highlight-active');
                        }
                    }
                }
            }

            function scrollElementIntoView(element) {
                isProgrammaticScroll = true; // Block header hiding
                const behavior = 'smooth'; 
                element.scrollIntoView({ behavior: behavior, block: 'center' });
                
                // Reset flag after the smooth scroll is expected to complete
                setTimeout(() => {
                    isProgrammaticScroll = false;
                }, PROGRAMMATIC_SCROLL_DURATION); 
            }

            function initializeTranscriptSync(transcriptMarkdown) {
                toggleHighlight(currentSegmentIndex, false);
                timestampSegments = [];
                currentSegmentIndex = -1;

                transcriptContent.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 py-8">Loading transcript...</div>';
                const initialHtml = marked.parse(transcriptMarkdown);
                transcriptContent.innerHTML = initialHtml;

                const segmentWrapperRegex = /\[\[(\d+\.?\d*)\]\]([\s\S]*?)(?=\[\[|$)/g;
                // Include h1-h6 for parsing as well
                const textContainers = transcriptContent.querySelectorAll('p, h1, h2, h3, h4, h5, h6, blockquote');

                textContainers.forEach(container => {
                    const contentToProcess = container.tagName === 'BLOCKQUOTE' ? container.innerHTML : container.outerHTML;
                    let lastProcessedIndex = 0;
                    let newContentHtml = '';
                    let match;

                    while ((match = segmentWrapperRegex.exec(contentToProcess)) !== null) {
                        newContentHtml += contentToProcess.substring(lastProcessedIndex, match.index);
                        const time = parseFloat(match[1]);
                        const content = match[2].trim();

                        const segmentHtml = `<span class="transcript-segment" data-time="${time}">${content}</span>`;
                        newContentHtml += segmentHtml;
                        lastProcessedIndex = match.index + match[0].length;
                    }

                    newContentHtml += contentToProcess.substring(lastProcessedIndex);
                    
                    if (container.tagName === 'P' || container.tagName.startsWith('H')) {
                         container.outerHTML = newContentHtml; 
                    } else {
                        container.innerHTML = newContentHtml; 
                    }
                });

                const segmentElements = document.querySelectorAll('#transcript-content .transcript-segment[data-time]');

                segmentElements.forEach(segmentElement => {
                    const time = parseFloat(segmentElement.dataset.time);
                    timestampSegments.push({
                        time: time,
                        element: segmentElement,
                        endTime: null
                    });
                });

                timestampSegments.sort((a, b) => a.time - b.time);

                for (let i = 0; i < timestampSegments.length; i++) {
                    if (i < timestampSegments.length - 1) {
                        timestampSegments[i].endTime = timestampSegments[i + 1].time;
                    } else {
                        audioPlayer.duration ? timestampSegments[i].endTime = audioPlayer.duration : Number.MAX_SAFE_INTEGER;
                    }
                }

                if (timestampSegments.length > 0) {
                    setTimeout(() => {
                        scrollElementIntoView(timestampSegments[0].element);
                    }, 50);
                }
            }

            audioPlayer.addEventListener('timeupdate', () => {
                const currentTime = audioPlayer.currentTime;
                let newSegmentIndex = currentSegmentIndex;

                for (let i = 0; i < timestampSegments.length; i++) {
                    const segment = timestampSegments[i];
                    if (currentTime >= segment.time && currentTime < segment.endTime) {
                        newSegmentIndex = i;
                        break;
                    } else if (i === timestampSegments.length - 1 && currentTime >= segment.time) {
                        newSegmentIndex = i;
                        break;
                    } else if (currentTime < timestampSegments[0].time && timestampSegments[0].time > 0) {
                        newSegmentIndex = -1;
                        break;
                    } else if (currentTime < timestampSegments[0].time && timestampSegments[0].time === 0 && currentSegmentIndex !== 0) {
                        newSegmentIndex = 0;
                        break;
                    }
                }

                if (newSegmentIndex !== currentSegmentIndex) {
                    toggleHighlight(currentSegmentIndex, false);
                    toggleHighlight(newSegmentIndex, true);
                    currentSegmentIndex = newSegmentIndex;

                    if (currentSegmentIndex !== -1) {
                        scrollElementIntoView(timestampSegments[currentSegmentIndex].element);
                    }
                }
            });

            transcriptContent.addEventListener('click', (event) => {
                let targetElement = event.target;
                while (targetElement && !targetElement.classList.contains('transcript-segment') && targetElement !== transcriptContent) {
                    targetElement = targetElement.parentNode;
                }

                if (targetElement && targetElement.classList.contains('transcript-segment')) {
                    const targetTime = parseFloat(targetElement.dataset.time);
                    if (!isNaN(targetTime)) {
                        audioPlayer.currentTime = targetTime;
                        audioPlayer.play();
                    }
                }
            });

            async function loadEpisode(episodeIndex, startTime = 0) {
                const selectedEpisode = playlist[episodeIndex];
                if (selectedEpisode) {
                    audioPlayer.src = selectedEpisode.audioSrc;
                    audioPlayer.load();

                    let transcriptContentMarkdown = '';
                    if (selectedEpisode.transcriptMarkdown) {
                        transcriptContentMarkdown = selectedEpisode.transcriptMarkdown;
                    } else if (selectedEpisode.transcriptUrl) {
                        transcriptContent.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 py-8">Loading transcript from GitHub...</div>';
                        try {
                            const transcriptFetchUrl = selectedEpisode.transcriptUrl + "?t=" + new Date().getTime();
                            const response = await fetch(transcriptFetchUrl);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            transcriptContentMarkdown = await response.text();
                        } catch (error) {
                            console.error('Error fetching transcript:', error);
                            transcriptContent.innerHTML = `<div class="text-center text-red-500 py-8">Error loading transcript: ${error.message}. Please check the URL.</div>`;
                            return;
                        }
                    }
                    initializeTranscriptSync(transcriptContentMarkdown);

                    audioPlayer.onloadedmetadata = () => {
                        if (startTime > 0 && startTime < audioPlayer.duration) {
                            audioPlayer.currentTime = startTime;
                        }
                        audioPlayer.onloadedmetadata = null;
                    };
                }
            }

            episodeSelect.addEventListener('change', (event) => {
                const selectedIndex = parseInt(event.target.value, 10);
                loadEpisode(selectedIndex);
                savePlaybackState();
            });

            function populatePlaylistDropdown() {
                episodeSelect.innerHTML = '';
                if (playlist.length === 0) {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "No episodes loaded";
                    episodeSelect.appendChild(option);
                    episodeSelect.disabled = true;
                    return;
                }
                episodeSelect.disabled = false;

                playlist.forEach((episode, index) => {
                    const option = document.createElement('option');
                    option.value = index.toString();
                    option.textContent = episode.title;
                    episodeSelect.appendChild(option);
                });
            }

            async function fetchPlaylistAndInitialize() {
                episodeSelect.innerHTML = '<option value="">Loading playlist...</option>';
                episodeSelect.disabled = true;
                try {
                    const response = await fetch(PLAYLIST_URL);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    playlist = await response.json();
                    populatePlaylistDropdown();

                    const savedState = applySavedPlaybackState();

                    if (playlist.length > 0) {
                        if (savedState && savedState.episodeIndex !== undefined) {
                            episodeSelect.value = savedState.episodeIndex;
                            loadEpisode(savedState.episodeIndex, savedState.startTime);
                        } else {
                            loadEpisode(0);
                        }
                    } else {
                        transcriptContent.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 py-8">No episodes found in playlist.json.</div>';
                    }
                } catch (error) {
                    console.error('Error fetching playlist:', error);
                    episodeSelect.innerHTML = '<option value="">Error loading playlist</option>';
                    transcriptContent.innerHTML = `<div class="text-center text-red-500 py-8">Error loading playlist: ${error.message}. Please check the playlist.json URL and content.</div>`;
                }
            }

            applySavedTheme();
            applySavedFontSize();
            applySavedVolume();
            fetchPlaylistAndInitialize();

            darkModeToggle.addEventListener('click', toggleDarkMode);
            fontSizeDecreaseBtn.addEventListener('click', () => changeFontSize(-FONT_SIZE_STEP));
            fontSizeIncreaseBtn.addEventListener('click', () => changeFontSize(FONT_SIZE_STEP));
            audioPlayer.addEventListener('volumechange', saveVolume);
            audioPlayer.addEventListener('pause', savePlaybackState);
            audioPlayer.addEventListener('ended', savePlaybackState);

            document.body.addEventListener('click', (event) => {
                const shouldIgnoreClick = event.target.closest('#fixed-header-area') || event.target.closest('.transcript-segment');

                if (!shouldIgnoreClick && !audioPlayer.paused) {
                    console.log("Background click detected: Pausing audio.");
                    audioPlayer.pause();
                }
            });
        });
    </script>
</body>
</html>

